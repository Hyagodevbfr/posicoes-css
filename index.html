<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Css Position</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Position</h1>
    <h2>Static</h2>
    <p>"Static é o posicionamento padrão, se nao definir nenhuma position no CSS, Position Static é o padrão, a ordem que aparece no browser, é a mesma que aparece no código."</p>

    <p>O elemento é posicionado de acordo com o fluxo normal do documento. O top, right, bottom, left, e z-index propriedades não têm efeito... Este é o valor padrão.</p>

    <div id="static">
        static
    </div>

    <h2>Relative</h2>
    <p>A position relative movimenta porem mantem o espaço original preservado, é sempre relativo à ele mesmo. Pode ser usada em conjunto com as seguintes propriedades: Top, left, botton, right.</p>

    <p>O elemento é posicionado de acordo com o fluxo normal do documento e, em seguida, deslocado em relação a si mesmo com base nos valores de top, right, bottom, e left. O deslocamento não afeta a posição de nenhum outro elemento; assim, o espaço dado para o elemento no layout da página é o mesmo que se a posição fosse static.</p><p>
        Este valor cria um novo stacking context (contexto de empilhamento) quando o valor de z-index não for auto. Seu efeito em table-*-group, table-row, table-column, table-cell e os elementos table-caption são indefinidos.</p>

    <div id="relative">
        <div id="absolute"><h2>Absolute</h2>
            absolute
        </div>
    </div>
    <h2>Absolute</h2>
    <p>
        A position <strong>absolute</strong> se relaciona muito bem quando esta dentro de um elemento de position relative.
    </p>

    <p> O elemento é posicionado de acordo com o fluxo normal do documento e, em seguida, deslocado em relação a si mesmo com base nos valores de top, right, bottom, e left. O deslocamento não afeta a posição de nenhum outro elemento; assim, o espaço dado para o elemento no layout da página é o mesmo que se a posição fosse static.</p><p>
        Este valor cria um novo stacking context (contexto de empilhamento) quando o valor de z-index não for auto. Seu efeito em table-*-group, table-row, table-column, table-cell e os elementos table-caption são indefinidos.</p>
    
    <h2>Fixed</h2>
    <div id="fixed">
        Fixed
    </div>
    <p>
        Ele vai ser sempre posicionado fixamente com a ViewPort.
    </p>

    <p>O elemento é removido do fluxo normal de documentos e nenhum espaço é criado para o elemento no layout da página. Ele está posicionado em relação ao inicial containing block estabelecido pelo viewport, exceto quando um de seus ancestrais tiver uma propriedade transform, perspective ou filter definida como algo diferente de none (see the CSS Transforms Spec), nesse caso, esse ancestral se comporta como o bloco que o contém. (Observe que há inconsistências no navegador com perspective e filter contribuindo para conter a formação do bloco.) Sua posição final é determinada pelos valores de top, right, bottom e left.</p><p>
        Este valor sempre cria um novo stacking context. Em documentos impressos, o elemento é colocado na mesma posição em todas as páginas.</p>

    <h2>Stick</h2>
    <div id="sticky">
        sticky
    </div>
    <p>
        Ele é um hibrido de position relative com position fixed
    </p>
    <p>O elemento é posicionado de acordo com o fluxo normal do documento e, em seguida, deslocado em relação ao ancestral de rolagem mais próximo e containing block (ancestral de nível de bloco mais próximo), incluindo elementos relacionados à tabela, com base nos valores de top, right, bottom e left. O deslocamento não afeta a posição de nenhum outro elemento.</p><p>
        Este valor sempre cria um novo stacking context. Observe que um elemento sticky "gruda" em seu ancestral mais próximo que possui um "mecanismo de rolagem" (criado quando overflow é hidden, scroll, auto ou overlay), mesmo que esse ancestral não seja o ancestral de rolagem mais próximo. Isso inibe efetivamente qualquer comportamento "pegajoso".</p>

</body>
</html>